window.app = window.app || {};

//takes care of handling messages and controlling windows

//#region PUBSUB
window.app.PubSub = new function () {
    var self = this;

    self.subscriptions = [];
    self.loggerService = null; //inject from angular service caller - eventServiceWrapper

    self.clearSubscriptions = function () {
        self.subscriptions = [];
    };

    self.getSubscriptionsForEvent = function (event, ctx) {
        var res = Enumerable.From(self.subscriptions).Where(function (x) {
            return x.event == event;
        });

        if (ctx) {
            res = res.Where(function (x) {
                return x.context == ctx;
            });
        }

        return res.ToArray();
    };

    self.subscribe = function (event, context, callback, priority) {
        // Check the validity of the subscription
        if (!event || !callback) { // || typeof callback != "function") {  <-- remove this check because IE8 passes functions as objects between related windows. Strange bug/by design. anyway, removing this check.
            throw ("Invalid parameters. Cannot initiate subscription. event: " + event);
        }

        // Create new guid to identify the subscription
        var subscriptionId = getNewGuid();

        // Saving the subscription
        self.subscriptions.push({
            id: subscriptionId,
            event: event,
            context: context,
            callback: callback,
            priority: priority
        });

        // Returning identifier to subscription, should be used to unsubscribe from this event
        return subscriptionId;
    };

    self.unsubscribe = function (subscriptionId) {
        // Getting the subscription according to subscription id
        var target = Enumerable.From(self.subscriptions).FirstOrDefault(null, function (x) {
            return x.id == subscriptionId;
        });

        if (!target) return;
        // removing the subscription
        self.subscriptions.remove(target);
    };

    self.publish = function (event, context, data) {
        // Get all subscriptions to specific event and context and also subscriptions to the specific event without context
        var targets = Enumerable.From(self.subscriptions).Where(function (x) {
            return x.event == event && (x.context == context || x.context == null);
        }).OrderBy("$.priority").ToArray();

        //To perform queue-like order, we rely on JS's "threading" system and put it in a timeout.
        window.setTimeout(function () {
            // Publish the event with the data to all subscribers
            for (var i = 0; i < targets.length; i++) {
                try {
                    targets[i].callback.apply(this, [].concat(data));
                    //targets[i].callback(data);
                } catch (ex) {
                    //do nothing. probably because popup window already closed
                }
            }
        }, 10);

    };

    self.NewEvent = function (eventName, severity, logMessage, parameters, context) {
        // Creating the log message
        if (logMessage === "undefined" || logMessage == null) {
            logMessage = eventName;
        } else {
            logMessage = eventName + ": " + logMessage;
        }

        if (self.loggerService) {
            self.loggerService.WriteLine("NewEvent: " + logMessage, severity, "eventServiceWrapper");
        }

        // Checking if context is defined
        if (context === undefined) {
            context = null;
        }
        // Publish the event being sent from Ajax API
        self.publish(eventName, context, parameters);
    };
};

//#endregion

//#region Gadget Communication and Window Actions

window.app.GadgetComm = new function () {
    var self = this;

    var windows = [];
    var pendingWindows = [];

    self.addPendingWindow = function (win) {
        pendingWindows.push(win);
    };

    self.getServicesByNameArray = function (serviceNames) {
        var svcs = [];
        var win = GetRootWindow();
        var injector = win.angular.element(win.document.querySelector('[ng-controller]')).injector();
        for (var i = 0; i < serviceNames.length; i++) {
            with ({ serviceName: serviceNames[i] }) {
                var service = injector.get(serviceName);
                svcs.push({ name: serviceName, svc: service });
            }
        }
        return svcs;
    };

    self.getPendingWindow = function (id) {
        var win = Enumerable.From(pendingWindows).FirstOrDefault(null, function (item) { return item.Id == id; });
        if (win) pendingWindows.remove(win);
        return win;
    };

    //opens a window and adds a method with args to queue array for firing once windows is opened
    self.OpenGadgetInstance = function (gadgetName, method, args) {
        var scope = angular.element("[ng-controller]").scope(); //TODO: direct reference to html. must be a better way to communicate with angular through regular JS. Shay? answer... there isn't.
        var win = scope.viewmodel.openGadgetWindow(gadgetName);
        if (!win) throw ("couldn't open new window for gadget '" + gadgetName + "'.");
        windows.push({ windowId: win.Id, method: method, args: args });
    };

    // ToDo: temp function for demo, need to remove
    self.makeCall = function (number) {
        var scope = angular.element("[ng-controller]").scope(); //TODO: direct reference to html. must be a better way to communicate with angular through regular JS. Shay? answer... there isn't.
        scope.viewmodel.makeCall(number);
    };

    self.windowReady = function (win) {
        if (!win) return;
        if (!win.windowId) return;
        var winDef = Enumerable.From(windows).Where("$.windowId=='" + win.windowId + "'").FirstOrDefault();
        if (!winDef) return;
        if (win[winDef.method]) {
            win[winDef.method](winDef.args);
        }

        //remove from array
        windows.remove(winDef);
    };

    self.launchComponentWindow = function (windowId, type, data) {
        var scope = angular.element("[ng-controller]").scope();
        scope.viewmodel.launchComponentWindow(windowId, type, data);
    };

    self.openSingleComponentWindow = function (winId, name, data, bringToFront) {
        var scope = angular.element("[ng-controller]").scope();
        return scope.viewmodel.openSingleComponentWindow(winId, name, data, bringToFront);
    };

    self.closeComponentWindow = function (windowId) {
        var scope = angular.element("[ng-controller]").scope();
        scope.viewmodel.closeWindow(windowId);
    };

    self.sendGadgetNotification = function (gadgetName, number) {
        var scope = angular.element("[ng-controller]").scope();
        scope.viewmodel.sendGadgetNotification(gadgetName, number);
    };

    self.clearGadgetNotifications = function (gadgetName) {
        var scope = angular.element("[ng-controller]").scope();
        scope.viewmodel.clearGadgetNotifications(gadgetName);
    };

    self.getWindowById = function (id) {
        var scope = angular.element("[ng-controller]").scope();
        return Enumerable.From(scope.viewmodel.ActiveWindows).FirstOrDefault(null, "$.Id=='" + id + "'");
    };
};

//#endregion
